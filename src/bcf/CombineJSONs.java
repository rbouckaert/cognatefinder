package bcf;

import org.json.*;

import java.io.File;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import beast.app.beauti.BeautiDoc;
import beast.app.util.Application;
import beast.app.util.OutFile;
import beast.core.Description;
import beast.core.Input;
import beast.core.Runnable;
import beast.core.util.Log;


@Description("Combine phoneme JSON files to get multiple alignments with a shared state encoding")
public class CombineJSONs extends Runnable {

	
	final public Input<List<File>> jsonInput = new Input<>("json", "A list of json files (generated by TSV2JSON)", new ArrayList<>());
	final public Input<String> languagesInput = new Input<>("languages", "Comma separated list of language names (one for each json file)", Input.Validate.REQUIRED);
	public Input<OutFile> outputInput = new Input<>("out", "output json file, or stdout if not specified", new OutFile("[[none]]"));
	
	final int codeLength = 2;
	
	int nFiles;
	String[] languages;
	
	@Override
	public void initAndValidate() {
		
		this.nFiles = jsonInput.get().size();
		if (this.nFiles < 2) throw new IllegalArgumentException("Please provide at least 2 json files");
		this.languages = languagesInput.get().split(",");
		if (this.languages.length != this.nFiles) {
			throw new IllegalArgumentException("Please ensure there is 1 language per json file. (There are " + this.nFiles + " files and " + this.languages.length + " languages)");
		}
		
		
	}

	@Override
	public void run() throws Exception {
		
		
		// Out json
		JSONObject json = new JSONObject();
		
		
		int nVowels = 0;
		int nConsonants = 0;
		String operators = "";
		
		// Get list of states from the sequences
		List<String> phonemes = new ArrayList<>();
		List<String> vowels = new ArrayList<>();
		List<String> consonants = new ArrayList<>();
		for (int fileNum = 0; fileNum < this.nFiles; fileNum++) {
			
			
			String languageID = this.languages[fileNum];
			Log.warning("Loading json for " + languageID + " from " + jsonInput.get().get(fileNum).getPath());
			
			// Load sequences from json
			String data = BeautiDoc.load(jsonInput.get().get(fileNum));
			JSONObject obj = new JSONObject(data);
			String sequences = obj.getString("sequences");
			json.append(languageID, sequences);
			
			// Vowel consonant count
			nVowels += obj.getInt("n-vowel-sites");
			nConsonants += obj.getInt("n-consonant-sites");
			
			operators += "<operator id='mutationRateDelta." + languageID + "' spec='beast.evolution.operators.DeltaExchangeOperator' weight='5'>\n" +
						        "<parameter idref='mutationRate.s:consonants:" + languageID + "'/>\n" +
						        "<parameter idref='mutationRate.s:vowels:" + languageID + "'/>\n" +
						        "<weightvector spec='beast.core.parameter.IntegerParameter' value='" + obj.getInt("n-vowel-sites") + " " + obj.getInt("n-consonant-sites") + "' />\n" +
					      "</operator>\n";
			
			
			
			// Load vowel and consonant datatypes from json
			String datatype_vowels_M2 = obj.getString("datatype_vowels_M2");
			String datatype_consonants_M2 = obj.getString("datatype_consonants_M2");
			
			for (String dataType : new String[] {datatype_vowels_M2, datatype_consonants_M2 }) {
				
				String codeMap = dataType.replaceAll(".+codeMap[=]'", "").replaceAll("'.+", "");
				Log.warning(codeMap);
				for (String pair : codeMap.split(",")) {
					String symbol = pair.split("[=]")[0];
					
					// Get vowel and consonant symbols (assuming that codeLen = 2)
					if (symbol.equals("..") || symbol.equals("-.") || symbol.equals(TSV2JSON.WILDCARD_VOWEL) || symbol.equals(TSV2JSON.WILDCARD_CONSONANT)) continue;
					
					if (dataType.equals(datatype_vowels_M2) && !vowels.contains(symbol)) {
						vowels.add(symbol);
						Log.warning("Detected vowel: " + symbol);
					}
					else if (dataType.equals(datatype_consonants_M2) && !consonants.contains(symbol)) {
						consonants.add(symbol);
						Log.warning("Detected consonant: " + symbol);
					}
					if (!phonemes.contains(symbol)) {
						phonemes.add(symbol);
					}
				}
					
				
			}
			
		}
		
		
		
		// Sort
		Collections.sort(phonemes);
		Collections.sort(vowels);
		Collections.sort(consonants);
		Log.warning("\n");
		Log.warning("Detected " + vowels.size() + " vowels " + vowels);
		Log.warning("Detected " + consonants.size() + " consonants " + consonants);
		
		
		
		
		
		// Combined state encoding 
		for (String arrName : new String[] { "phonemes" ,"vowels" ,"consonants" }) {
			
			List<String> list = arrName.equals("phonemes") ? phonemes : arrName.equals("vowels") ? vowels : consonants;
			
			// Add gaps
			list.add("..");
			list.add("-.");
			list.add(TSV2JSON.WILDCARD_VOWEL);
			list.add(TSV2JSON.WILDCARD_CONSONANT);
			
			int nsymbols = list.size();
			int nstates = nsymbols - 4; // Minus gaps
			String codeMap = "";
			for (int i = 0; i < nsymbols; i ++) {
				String symbol = list.get(i);
				String states = "";
				
				// Ambiguous
				if (symbol.equals("..") || symbol.equals("-.") || symbol.equals(TSV2JSON.WILDCARD_VOWEL) || symbol.equals(TSV2JSON.WILDCARD_CONSONANT)) {
					for (int j = 0; j < nstates; j ++) {
						states += j;
						if (j < nstates-1) states += " ";
					}
				}
				
				// Non ambiguous
				else {
					states = "" + i;
				}
				
				
				codeMap += symbol + "=" + states;
				if (i < nsymbols-1) codeMap += ",";
			}
			
			
			String id = "datatype_" + arrName + "_M2";
			String xml = "<userDataType id='" + id + "' spec='beast.phoneme.UserPhonemeDataType' states='" + nstates + "' codelength='2' codeMap='" + codeMap + "'/>";
			json.put(id, xml);
			
			
			// Number of gtr rates
			json.put("gtrSymRatesM2_" + arrName, nstates*(nstates-1) / 2);
			json.put("gtrAsymRatesM2_" + arrName, nstates*(nstates-1));
			
		}
		json.put("languages", String.join(",", languages));
		
		
		// Sum vowel and consonant counts
		json.put("n-vowel-sites", nVowels);
		json.put("n-consonant-sites", nConsonants);
		json.put("deltaExchange", operators);
		
		
		
		
		
		PrintStream out = System.out;
		if (outputInput.get() != null && !outputInput.get().getName().equals("[[none]]")) {
			Log.warning("Writing to file " + outputInput.get().getName());
			out = new PrintStream(outputInput.get());
		}
		
		String o = json.toString(4);
		o = o.replaceAll("\\\\n", "\n\t\t").replaceAll("\\\\/", "/");
		out.println(o);
		out.close();
		
		
		
	}

	
	
	
	
	
	
	
	public static void main(String[] args) throws Exception {
		new Application(new CombineJSONs(), "Combine phoneme JSON files to get multiple alignments with a shared state encoding", args);
	}
	
	
}
